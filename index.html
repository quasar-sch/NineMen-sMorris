<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Nine Men's Morris</title>
  <style>
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo",
        "Noto Sans KR", Segoe UI, Roboto, Helvetica, Arial;
      text-align: center;
      background: #f3f4f6;
      margin: 0;
      padding: 40px 16px;
      box-sizing: border-box;
    }
    h1 {
      margin-top: 0;
      margin-bottom: 16px;
    }
    #start-screen,
    #game-screen {
      max-width: 640px;
      margin: 0 auto;
    }
    .hidden {
      display: none;
    }
    button {
      padding: 10px 16px;
      margin: 6px;
      font-size: 15px;
      cursor: pointer;
      border-radius: 8px;
      border: 1px solid #4b5563;
      background: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
      transition: 0.15s transform, 0.15s box-shadow, 0.15s background;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
      background: #f9fafb;
    }

    #info-bar {
      margin-bottom: 12px;
      font-size: 15px;
    }
    #info-bar > div {
      margin: 2px 0;
    }

    #board-wrapper {
      display: flex;
      justify-content: center;
    }
    #board {
      width: 400px;
      max-width: 90vw;
      aspect-ratio: 1 / 1;
      position: relative;
      border-radius: 18px;
      background: radial-gradient(circle at 20% -10%, #e5e7eb, #d1d5db);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.16);
      border: 2px solid #4b5563;
      overflow: hidden;
    }
    /* 보드 선 */
    #board::before,
    #board::after {
      content: "";
      position: absolute;
      inset: 12%;
      border: 2px solid #9ca3af;
    }
    #board::after {
      inset: 26%;
    }
    /* 가운데 십자선 */
    #board::marker;
    #board::selection;
    #board .cross-h,
    #board .cross-v {
      position: absolute;
      background: #9ca3af;
    }
    .cross-h {
      left: 12%;
      right: 12%;
      top: 50%;
      height: 2px;
    }
    .cross-v {
      top: 12%;
      bottom: 12%;
      left: 50%;
      width: 2px;
    }

    .cell {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid #111827;
      position: absolute;
      transform: translate(-50%, -50%);
      box-sizing: border-box;
    }
    .cell.empty {
      background-color: #f9fafb;
    }
    .cell.W {
      background-color: #fefce8;
    }
    .cell.B {
      background-color: #111827;
    }
    .cell.selected {
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.65);
    }

    #hint-text {
      margin-top: 10px;
      font-size: 13px;
      color: #4b5563;
      min-height: 20px;
    }

    /* 결과 오버레이 */
    #result-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    /* hidden 클래스와 같이 쓰일 때는 진짜 안 보이도록 */
    #result-overlay.hidden {
      display: none;
    }
    #result-box {
      background: #111827;
      color: #f9fafb;
      padding: 20px 24px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      min-width: 260px;
      max-width: 90vw;
      text-align: center;
      border: 1px solid #4b5563;
    }
    #result-message {
      font-size: 22px;
      margin-bottom: 12px;
    }
    #result-box p {
      margin: 4px 0 14px;
      font-size: 13px;
      color: #e5e7eb;
    }
  </style>
</head>
<body>
  <!-- 시작 화면 -->
  <div id="start-screen">
    <h1>Nine Men's Morris</h1>
    <p>혼자 게임하기: 플레이어 vs 컴퓨터 (선/후공 랜덤)</p>
    <p>둘이 게임하기: 같은 컴퓨터에서 번갈아 두기</p>
    <button id="btn-single">혼자 게임하기</button>
    <button id="btn-multi">둘이 게임하기</button>
  </div>

  <!-- 게임 화면 -->
  <div id="game-screen" class="hidden">
    <div id="info-bar">
      <div id="mode-text"></div>
      <div id="turn-text"></div>
    </div>

    <div id="board-wrapper">
      <div id="board">
        <!-- 가운데 십자선 -->
        <div class="cross-h"></div>
        <div class="cross-v"></div>

        <!-- 인덱스와 JS 로직을 맞춘 24개의 점 -->
        <!-- 위쪽 3개 (0,1,2) -->
        <div class="cell empty" data-index="0" style="left: 10%; top: 10%;"></div>
        <div class="cell empty" data-index="1" style="left: 50%; top: 10%;"></div>
        <div class="cell empty" data-index="2" style="left: 90%; top: 10%;"></div>

        <!-- 두번째 줄 (3,4,5) -->
        <div class="cell empty" data-index="3" style="left: 20%; top: 20%;"></div>
        <div class="cell empty" data-index="4" style="left: 50%; top: 20%;"></div>
        <div class="cell empty" data-index="5" style="left: 80%; top: 20%;"></div>

        <!-- 세번째 줄 (6,7,8) -->
        <div class="cell empty" data-index="6" style="left: 30%; top: 30%;"></div>
        <div class="cell empty" data-index="7" style="left: 50%; top: 30%;"></div>
        <div class="cell empty" data-index="8" style="left: 70%; top: 30%;"></div>

        <!-- 가운데 가로줄 왼쪽 (9,10,11) -->
        <div class="cell empty" data-index="9" style="left: 10%; top: 50%;"></div>
        <div class="cell empty" data-index="10" style="left: 20%; top: 50%;"></div>
        <div class="cell empty" data-index="11" style="left: 30%; top: 50%;"></div>

        <!-- 가운데 가로줄 오른쪽 (12,13,14) -->
        <div class="cell empty" data-index="12" style="left: 70%; top: 50%;"></div>
        <div class="cell empty" data-index="13" style="left: 80%; top: 50%;"></div>
        <div class="cell empty" data-index="14" style="left: 90%; top: 50%;"></div>

        <!-- 아래에서 두번째 줄 (15,16,17) -->
        <div class="cell empty" data-index="15" style="left: 30%; top: 70%;"></div>
        <div class="cell empty" data-index="16" style="left: 50%; top: 70%;"></div>
        <div class="cell empty" data-index="17" style="left: 70%; top: 70%;"></div>

        <!-- 아래에서 세번째 줄 (18,19,20) -->
        <div class="cell empty" data-index="18" style="left: 20%; top: 80%;"></div>
        <div class="cell empty" data-index="19" style="left: 50%; top: 80%;"></div>
        <div class="cell empty" data-index="20" style="left: 80%; top: 80%;"></div>

        <!-- 맨 아래 줄 (21,22,23) -->
        <div class="cell empty" data-index="21" style="left: 10%; top: 90%;"></div>
        <div class="cell empty" data-index="22" style="left: 50%; top: 90%;"></div>
        <div class="cell empty" data-index="23" style="left: 90%; top: 90%;"></div>
      </div>
    </div>

    <div id="hint-text"></div>

    <div style="margin-top:14px;">
      <button id="btn-back">처음으로</button>
    </div>
  </div>

  <!-- 결과 오버레이 -->
  <div id="result-overlay" class="hidden">
    <div id="result-box">
      <div id="result-message"></div>
      <p id="result-detail"></p>
      <button id="btn-restart">같은 모드로 다시 하기</button>
      <button id="btn-to-start">처음 화면으로</button>
    </div>
  </div>

  <script>
    const MODE = {
      SINGLE: "single",
      MULTI: "multi",
    };

    const EMPTY = null;
    const WHITE = "W";
    const BLACK = "B";

    let mode = null;
    let board = Array(24).fill(EMPTY);
    let currentSide = WHITE;
    let piecesToPlace = { W: 9, B: 9 };
    let pieceCount = { W: 0, B: 0 };

    let humanSide = null;
    let aiSide = null;

    let gameOver = false;
    let mustRemoveSide = null;
    let selectedIndex = null;

    const startScreen = document.getElementById("start-screen");
    const gameScreen = document.getElementById("game-screen");
    const resultOverlay = document.getElementById("result-overlay");
    const resultMessage = document.getElementById("result-message");
    const resultDetail = document.getElementById("result-detail");
    const modeText = document.getElementById("mode-text");
    const turnText = document.getElementById("turn-text");
    const hintText = document.getElementById("hint-text");
    const boardEl = document.getElementById("board");

    // 인접 점 정보
    const neighbors = {
      0: [1, 9],
      1: [0, 2, 4],
      2: [1, 14],
      3: [4, 10],
      4: [1, 3, 5, 7],
      5: [4, 13],
      6: [7, 11],
      7: [4, 6, 8],
      8: [7, 12],
      9: [0, 10, 21],
      10: [3, 9, 11, 18],
      11: [6, 10, 15],
      12: [8, 13, 17],
      13: [5, 12, 14, 20],
      14: [2, 13, 23],
      15: [11, 16],
      16: [15, 17, 19],
      17: [12, 16],
      18: [10, 19],
      19: [16, 18, 20, 22],
      20: [13, 19],
      21: [9, 22],
      22: [19, 21, 23],
      23: [14, 22],
    };

    // 대각선 없이 가로·세로 밀만
    const mills = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [9, 10, 11],
      [12, 13, 14],
      [15, 16, 17],
      [18, 19, 20],
      [21, 22, 23],
      [0, 9, 21],
      [3, 10, 18],
      [6, 11, 15],
      [1, 4, 7],
      [16, 19, 22],
      [8, 12, 17],
      [5, 13, 20],
      [2, 14, 23],
    ];

    function otherSide(side) {
      return side === WHITE ? BLACK : WHITE;
    }

    function cellEl(i) {
      return boardEl.querySelector('.cell[data-index="' + i + '"]');
    }

    function clearSelection() {
      if (selectedIndex !== null) {
        cellEl(selectedIndex)?.classList.remove("selected");
      }
      selectedIndex = null;
    }

    function resetBoardVisual() {
      boardEl.querySelectorAll(".cell").forEach((cell) => {
        cell.classList.remove("W", "B", "selected");
        cell.classList.add("empty");
      });
    }

    function placePiece(index, side) {
      board[index] = side;
      pieceCount[side]++;
      const el = cellEl(index);
      if (el) {
        el.classList.remove("empty", "W", "B", "selected");
        el.classList.add(side);
      }
    }

    function movePiece(from, to, side) {
      board[from] = EMPTY;
      board[to] = side;
      const fromEl = cellEl(from);
      const toEl = cellEl(to);
      if (fromEl) {
        fromEl.classList.remove("W", "B", "selected");
        fromEl.classList.add("empty");
      }
      if (toEl) {
        toEl.classList.remove("empty", "W", "B", "selected");
        toEl.classList.add(side);
      }
    }

    function removePiece(index, side) {
      if (board[index] !== side) return;
      board[index] = EMPTY;
      pieceCount[side]--;
      const el = cellEl(index);
      if (el) {
        el.classList.remove("W", "B", "selected");
        el.classList.add("empty");
      }
    }

    function isMillAt(index, side) {
      return mills.some(
        (m) => m.includes(index) && m.every((i) => board[i] === side)
      );
    }

    // 이제는 어떤 말이든 제거 가능 → 상대 말만 있으면 OK
    function existsRemovableOpponentPiece(forSide) {
      const opp = otherSide(forSide);
      return pieceCount[opp] > 0;
    }
    function canRemoveThis(index, removerSide) {
      const opp = otherSide(removerSide);
      return board[index] === opp;
    }

    // 이동 가능한 수가 있는지 (점프 없음, 항상 인접 이동)
    function hasAnyLegalMove(side) {
      if (piecesToPlace.W > 0 || piecesToPlace.B > 0) return true; // 포석 중이면 무조건 있음
      if (pieceCount[side] <= 2) return false; // 이미 패배 상태
      for (let i = 0; i < 24; i++) {
        if (board[i] !== side) continue;
        for (const n of neighbors[i]) {
          if (board[n] === EMPTY) return true;
        }
      }
      return false;
    }

    function checkGameOver(afterSide) {
      const opp = otherSide(afterSide);
      // 1) 상대 말 2개 이하
      if (pieceCount[opp] <= 2 && piecesToPlace.W === 0 && piecesToPlace.B === 0) {
        endGame(afterSide, "pieces");
        return true;
      }
      // 2) 상대가 더 이상 움직일 수 없음
      if (
        piecesToPlace.W === 0 &&
        piecesToPlace.B === 0 &&
        !hasAnyLegalMove(opp)
      ) {
        endGame(afterSide, "noMoves");
        return true;
      }
      return false;
    }

    function updateInfoBar() {
      if (mode === MODE.SINGLE) {
        const who =
          humanSide === WHITE
            ? "플레이어 = 흰 말(선공)"
            : "플레이어 = 검은 말(후공)";
        modeText.textContent = `모드: 혼자 게임하기 (${who})`;
      } else if (mode === MODE.MULTI) {
        modeText.textContent = "모드: 둘이 게임하기";
      } else {
        modeText.textContent = "";
      }

      let turnStr = currentSide === WHITE ? "흰 말 차례" : "검은 말 차례";
      if (mode === MODE.SINGLE) {
        turnStr += currentSide === humanSide ? " (플레이어)" : " (컴퓨터)";
      }
      turnText.textContent = turnStr;

      if (mustRemoveSide && mustRemoveSide === currentSide) {
        hintText.textContent = "밀 완성! 상대 말을 하나 클릭해서 제거하세요.";
        return;
      }

      if (piecesToPlace.W > 0 || piecesToPlace.B > 0) {
        hintText.textContent =
          "포석 단계: 번갈아 말을 빈 점에 놓습니다. (각 9개)";
      } else {
        hintText.textContent =
          "이동 단계: 자신의 말을 인접한 빈 점으로 한 칸씩 이동합니다. (대각선·점프 없음)";
      }
    }

    function endGame(winnerSide, reason) {
      gameOver = true;
      let msg = "";
      let detail = "";

      if (mode === MODE.SINGLE) {
        msg = winnerSide === humanSide ? "플레이어 승!" : "컴퓨터 승!";
      } else {
        msg = winnerSide === WHITE ? "흰 말 승!" : "검은 말 승!";
      }

      if (reason === "noMoves") {
        detail = "상대가 더 이상 움직일 수 없어서 승리했습니다.";
      } else if (reason === "pieces") {
        detail = "상대 말이 2개 이하로 남아서 승리했습니다.";
      }

      resultMessage.textContent = msg;
      resultDetail.textContent = detail;
      resultOverlay.classList.remove("hidden");
    }

    function initGameState() {
      board = Array(24).fill(EMPTY);
      piecesToPlace = { W: 9, B: 9 };
      pieceCount = { W: 0, B: 0 };
      currentSide = WHITE;
      gameOver = false;
      mustRemoveSide = null;
      clearSelection();
      resetBoardVisual();
    }

    function goToGameScreen() {
      startScreen.classList.add("hidden");
      gameScreen.classList.remove("hidden");
    }

    function goToStartScreen() {
      gameScreen.classList.add("hidden");
      startScreen.classList.remove("hidden");
      resultOverlay.classList.add("hidden");
    }

    function startSingleGame() {
      mode = MODE.SINGLE;
      initGameState();
      humanSide = Math.random() < 0.5 ? WHITE : BLACK;
      aiSide = otherSide(humanSide);
      goToGameScreen();
      updateInfoBar();

      if (currentSide === aiSide) {
        setTimeout(aiTurn, 500);
      }
    }

    function startMultiGame() {
      mode = MODE.MULTI;
      humanSide = null;
      aiSide = null;
      initGameState();
      goToGameScreen();
      updateInfoBar();
    }

    function restartCurrentMode() {
      resultOverlay.classList.add("hidden");
      if (mode === MODE.SINGLE) startSingleGame();
      else if (mode === MODE.MULTI) startMultiGame();
    }

    // 클릭 처리
    function handleBoardClick(index) {
      if (gameOver) return;
      if (mode === MODE.SINGLE && currentSide === aiSide) return;

      // 제거 단계
      if (mustRemoveSide) {
        if (mustRemoveSide !== currentSide) return;
        if (!canRemoveThis(index, currentSide)) return;

        const opp = otherSide(currentSide);
        removePiece(index, opp);
        mustRemoveSide = null;

        if (checkGameOver(currentSide)) return;
        currentSide = otherSide(currentSide);
        clearSelection();
        updateInfoBar();
        if (mode === MODE.SINGLE && currentSide === aiSide) {
          setTimeout(aiTurn, 500);
        }
        return;
      }

      // 포석 vs 이동
      if (piecesToPlace.W > 0 || piecesToPlace.B > 0) {
        handlePlacingPhaseClick(index);
      } else {
        handleMovingPhaseClick(index);
      }
    }

    function handlePlacingPhaseClick(index) {
      if (board[index] !== EMPTY) return;

      placePiece(index, currentSide);
      piecesToPlace[currentSide]--;

      if (isMillAt(index, currentSide) && existsRemovableOpponentPiece(currentSide)) {
        mustRemoveSide = currentSide;
        updateInfoBar();
        return;
      }

      if (checkGameOver(currentSide)) return;

      currentSide = otherSide(currentSide);
      updateInfoBar();

      if (mode === MODE.SINGLE && currentSide === aiSide) {
        setTimeout(aiTurn, 500);
      }
    }

    function handleMovingPhaseClick(index) {
      const side = currentSide;

      if (selectedIndex === null) {
        if (board[index] !== side) return;
        selectedIndex = index;
        cellEl(index)?.classList.add("selected");
      } else {
        if (index === selectedIndex) {
          clearSelection();
          return;
        }

        if (board[index] !== EMPTY) {
          if (board[index] === side) {
            cellEl(selectedIndex)?.classList.remove("selected");
            selectedIndex = index;
            cellEl(index)?.classList.add("selected");
          }
          return;
        }

        const from = selectedIndex;
        const to = index;
        let legal = false;

        // ★ 점프 없음: 항상 인접 칸으로만 이동
        if (neighbors[from].includes(to)) legal = true;
        if (!legal) return;

        movePiece(from, to, side);
        clearSelection();

        if (isMillAt(to, side) && existsRemovableOpponentPiece(side)) {
          mustRemoveSide = side;
          updateInfoBar();
          return;
        }

        if (checkGameOver(side)) return;
        currentSide = otherSide(currentSide);
        updateInfoBar();

        if (mode === MODE.SINGLE && currentSide === aiSide) {
          setTimeout(aiTurn, 500);
        }
      }
    }

    // ---------------- AI ----------------
    function aiTurn() {
      if (gameOver) return;
      if (currentSide !== aiSide) return;

      if (mustRemoveSide === aiSide) {
        const target = pickAiRemoveTarget(aiSide);
        if (target !== null) {
          const opp = otherSide(aiSide);
          removePiece(target, opp);
          mustRemoveSide = null;
          if (checkGameOver(aiSide)) return;
          currentSide = otherSide(aiSide);
          updateInfoBar();
        }
        return;
      }

      // 포석
      if (piecesToPlace.W > 0 || piecesToPlace.B > 0) {
        const idx = pickAiPlaceIndex(aiSide);
        if (idx === null) return;
        placePiece(idx, aiSide);
        piecesToPlace[aiSide]--;

        if (isMillAt(idx, aiSide) && existsRemovableOpponentPiece(aiSide)) {
          mustRemoveSide = aiSide;
          updateInfoBar();
          setTimeout(aiTurn, 500);
          return;
        }

        if (checkGameOver(aiSide)) return;
        currentSide = otherSide(aiSide);
        updateInfoBar();
        return;
      }

      // 이동 (점프 없음)
      const move = pickAiMove(aiSide);
      if (!move) {
        if (!hasAnyLegalMove(aiSide)) {
          endGame(otherSide(aiSide), "noMoves");
        }
        return;
      }

      movePiece(move.from, move.to, aiSide);

      if (isMillAt(move.to, aiSide) && existsRemovableOpponentPiece(aiSide)) {
        mustRemoveSide = aiSide;
        updateInfoBar();
        setTimeout(aiTurn, 500);
        return;
      }

      if (checkGameOver(aiSide)) return;
      currentSide = otherSide(aiSide);
      updateInfoBar();
    }

    function pickAiPlaceIndex(side) {
      const opp = otherSide(side);

      // 1) 나 밀 만들기
      for (let i = 0; i < 24; i++) {
        if (board[i] !== EMPTY) continue;
        board[i] = side;
        const ok = isMillAt(i, side);
        board[i] = EMPTY;
        if (ok) return i;
      }

      // 2) 상대 밀 막기
      for (let i = 0; i < 24; i++) {
        if (board[i] !== EMPTY) continue;
        board[i] = opp;
        const ok = isMillAt(i, opp);
        board[i] = EMPTY;
        if (ok) return i;
      }

      // 3) 랜덤
      const empties = [];
      for (let i = 0; i < 24; i++) if (board[i] === EMPTY) empties.push(i);
      if (!empties.length) return null;
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function pickAiRemoveTarget(side) {
      const opp = otherSide(side);
      const candidates = [];
      for (let i = 0; i < 24; i++) if (board[i] === opp) candidates.push(i);
      if (!candidates.length) return null;
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function pickAiMove(side) {
      const opp = otherSide(side);
      const moves = [];

      // 인접 칸으로만
      for (let from = 0; from < 24; from++) {
        if (board[from] !== side) continue;
        for (const to of neighbors[from]) {
          if (board[to] === EMPTY) moves.push({ from, to });
        }
      }
      if (!moves.length) return null;

      // 1) 내 밀 만드는 이동
      for (const m of moves) {
        board[m.from] = EMPTY;
        board[m.to] = side;
        const ok = isMillAt(m.to, side);
        board[m.to] = EMPTY;
        board[m.from] = side;
        if (ok) return m;
      }

      // 2) 상대 밀 막는 이동
      for (const m of moves) {
        board[m.from] = EMPTY;
        board[m.to] = opp;
        const ok = isMillAt(m.to, opp);
        board[m.to] = EMPTY;
        board[m.from] = side;
        if (ok) return m;
      }

      // 3) 랜덤
      return moves[Math.floor(Math.random() * moves.length)];
    }

    // 이벤트
    document.getElementById("btn-single").addEventListener("click", startSingleGame);
    document.getElementById("btn-multi").addEventListener("click", startMultiGame);
    document.getElementById("btn-back").addEventListener("click", goToStartScreen);
    document
      .getElementById("btn-restart")
      .addEventListener("click", restartCurrentMode);
    document
      .getElementById("btn-to-start")
      .addEventListener("click", () => {
        resultOverlay.classList.add("hidden");
        goToStartScreen();
      });

    boardEl.addEventListener("click", (e) => {
      const cell = e.target.closest(".cell");
      if (!cell) return;
      const idx = Number(cell.dataset.index);
      handleBoardClick(idx);
    });
  </script>
</body>
</html>

<!-- © 2025 이 자료의 저작권은 quasar.sch에게 있습니다. -->
