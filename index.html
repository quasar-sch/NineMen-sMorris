<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Nine Men's Morris</title>
<style>
:root{
  --board-bg:#d1d5db;
  --board-edge:#4b5563;
  --line:#4b5563;
  --white-piece:#fef3c7;
  --white-border:#b45309;
  --black-piece:#020617;
  --black-border:#e5e7eb;
}
*{box-sizing:border-box;}

body{
  margin:0;
  padding:40px 16px;
  background:#f3f4f6;
  font-family:ui-sans-serif,system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",Segoe UI,Roboto,Helvetica,Arial;
  text-align:center;
}

button{
  padding:10px 16px;
  margin:6px;
  font-size:15px;
  cursor:pointer;
  border-radius:8px;
  border:1px solid #4b5563;
  background:#fff;
  transition:0.15s;
}
button:hover{
  transform:translateY(-1px);
  background:#f9fafb;
  box-shadow:0 4px 10px rgba(0,0,0,0.12);
}
.hidden{display:none;}

#game-screen,#start-screen{
  max-width:640px;
  margin:0 auto;
}

#board-wrapper{display:flex;justify-content:center;}

#board{
  width:400px;
  max-width:90vw;
  aspect-ratio:1/1;
  position:relative;
  border-radius:24px;
  background:radial-gradient(circle at 20% -10%,#e5e7eb,var(--board-bg));
  border:3px solid var(--board-edge);
  box-shadow:0 12px 40px rgba(0,0,0,0.22);
  overflow:hidden;
}

/* SVG 라인 (이동 가능 경로만) */
#edges{
  position:absolute;
  inset:0;
  z-index:0;
}
#edges line{
  stroke:var(--line);
  stroke-width:2.5;
  stroke-linecap:round;
}

/* 말/점 */
.cell{
  width:24px;height:24px;border-radius:50%;
  position:absolute;transform:translate(-50%,-50%);
  cursor:pointer;z-index:1;
}
.cell.empty{background:#e5e7eb;border:2px solid var(--board-edge);}
.cell.W{
  background:#fef3c7;border:3px solid var(--white-border);
  box-shadow:0 0 0 2px rgba(255,255,255,0.7);
}
.cell.B{
  background:#020617;border:3px solid var(--black-border);
  box-shadow:0 0 0 2px rgba(0,0,0,0.5);
}
.cell.selected{box-shadow:0 0 0 4px rgba(59,130,246,0.9);}

#result-overlay{
  position:fixed;inset:0;
  background:rgba(15,23,42,0.55);
  display:flex;align-items:center;justify-content:center;
  z-index:1000;
}
#result-overlay.hidden{display:none;}
#result-box{
  background:#111827;color:#f9fafb;
  padding:20px;border-radius:16px;
  border:1px solid #4b5563;
  min-width:260px;
}
</style>
</head>

<body>

<!-- 시작 화면 -->
<div id="start-screen">
  <h1>Nine Men's Morris</h1>
  <p>혼자 게임하기: 플레이어 vs 컴퓨터 (선/후공 랜덤)</p>
  <p>둘이 게임하기: 같은 컴퓨터에서 번갈아 두기</p>
  <button id="btn-single">혼자 게임하기</button>
  <button id="btn-multi">둘이 게임하기</button>
</div>

<!-- 게임 화면 -->
<div id="game-screen" class="hidden">
  <div id="mode-text"></div>
  <div id="turn-text"></div>
  <div id="role-text" style="font-size:13px;color:#4b5563;margin-bottom:8px;"></div>

  <div id="board-wrapper">
    <div id="board">
      <!-- 이동 경로용 SVG -->
      <svg id="edges" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>

      <!-- 24개 점 -->
      <!-- 바깥 8 -->
      <div class="cell empty" data-index="0"  style="left:10%; top:10%;"></div>
      <div class="cell empty" data-index="1"  style="left:50%; top:10%;"></div>
      <div class="cell empty" data-index="2"  style="left:90%; top:10%;"></div>
      <div class="cell empty" data-index="9"  style="left:10%; top:50%;"></div>
      <div class="cell empty" data-index="14" style="left:90%; top:50%;"></div>
      <div class="cell empty" data-index="21" style="left:10%; top:90%;"></div>
      <div class="cell empty" data-index="22" style="left:50%; top:90%;"></div>
      <div class="cell empty" data-index="23" style="left:90%; top:90%;"></div>

      <!-- 중간 8 -->
      <div class="cell empty" data-index="3"  style="left:20%; top:20%;"></div>
      <div class="cell empty" data-index="4"  style="left:50%; top:20%;"></div>
      <div class="cell empty" data-index="5"  style="left:80%; top:20%;"></div>
      <div class="cell empty" data-index="10" style="left:20%; top:50%;"></div>
      <div class="cell empty" data-index="13" style="left:80%; top:50%;"></div>
      <div class="cell empty" data-index="18" style="left:20%; top:80%;"></div>
      <div class="cell empty" data-index="19" style="left:50%; top:80%;"></div>
      <div class="cell empty" data-index="20" style="left:80%; top:80%;"></div>

      <!-- 안쪽 8 -->
      <div class="cell empty" data-index="6"  style="left:30%; top:30%;"></div>
      <div class="cell empty" data-index="7"  style="left:50%; top:30%;"></div>
      <div class="cell empty" data-index="8"  style="left:70%; top:30%;"></div>
      <div class="cell empty" data-index="11" style="left:30%; top:50%;"></div>
      <div class="cell empty" data-index="12" style="left:70%; top:50%;"></div>
      <div class="cell empty" data-index="15" style="left:30%; top:70%;"></div>
      <div class="cell empty" data-index="16" style="left:50%; top:70%;"></div>
      <div class="cell empty" data-index="17" style="left:70%; top:70%;"></div>
    </div>
  </div>

  <div id="hint-text" style="margin-top:8px;font-size:13px;color:#4b5563;"></div>

  <button id="btn-back" style="margin-top:10px;">처음으로</button>
</div>

<!-- 결과 화면 -->
<div id="result-overlay" class="hidden">
  <div id="result-box">
    <div id="result-message" style="font-size:22px;margin-bottom:8px;"></div>
    <div id="result-detail" style="font-size:13px;color:#e5e7eb;margin-bottom:16px;"></div>
    <button id="btn-restart">같은 모드로 다시 하기</button>
    <button id="btn-to-start">처음 화면으로</button>
  </div>
</div>

<script>
// ===== 상수 & 상태 =====
const MODE = { SINGLE:'single', MULTI:'multi' };
const EMPTY = null, WHITE='W', BLACK='B';
const MAX_PIECES = 9;
const AI_DELAY = 500; // AI 딜레이 0.5초

let mode = null;
let board = Array(24).fill(EMPTY);
let currentSide = WHITE;
let humanSide = null;
let aiSide = null;
let placed = { W:0, B:0 }; // 포석으로 올린 말 수
let count  = { W:0, B:0 }; // 현재 판 위 말 수
let selectedIndex = null;
let gameOver = false;
let pendingRemovalSide = null; // 밀 만든 쪽이 제거를 기다리는 상태

// 좌표 (퍼센트)
const coord = {
  0:{x:10,y:10}, 1:{x:50,y:10}, 2:{x:90,y:10},
  3:{x:20,y:20}, 4:{x:50,y:20}, 5:{x:80,y:20},
  6:{x:30,y:30}, 7:{x:50,y:30}, 8:{x:70,y:30},
  9:{x:10,y:50},10:{x:20,y:50},11:{x:30,y:50},12:{x:70,y:50},13:{x:80,y:50},14:{x:90,y:50},
 15:{x:30,y:70},16:{x:50,y:70},17:{x:70,y:70},
 18:{x:20,y:80},19:{x:50,y:80},20:{x:80,y:80},
 21:{x:10,y:90},22:{x:50,y:90},23:{x:90,y:90}
};

// 인접 리스트 (여기에만 선 그리고 이동 허용)
const adj = {
  0:[1,9],
  1:[0,2,4],
  2:[1,14],
  3:[4,10],
  4:[1,3,5,7],
  5:[4,13],
  6:[7,11],
  7:[4,6,8],
  8:[7,12],
  9:[0,10,21],
 10:[3,9,11,18],
 11:[6,10,15],
 12:[8,13,17],
 13:[5,12,14,20],
 14:[2,13,23],
 15:[11,16],
 16:[15,17,19],
 17:[12,16],
 18:[10,19],
 19:[16,18,20,22],
 20:[13,19],
 21:[9,22],
 22:[19,21,23],
 23:[14,22]
};

// 밀 패턴 (3개 일직선)
const mills = [
  [0,1,2],[3,4,5],[6,7,8],
  [15,16,17],[18,19,20],[21,22,23],
  [0,9,21],[3,10,18],[6,11,15],
  [8,12,17],[5,13,20],[2,14,23],
  [1,4,7],[16,19,22]
];

const otherSide = s => s===WHITE?BLACK:WHITE;
const isMovingPhase = () => placed.W>=MAX_PIECES && placed.B>=MAX_PIECES;
const cellEl = i => document.querySelector(`.cell[data-index="${i}"]`);

// ===== 라인 그리기 =====
(function drawEdges(){
  const svg=document.getElementById('edges');
  const drawn=new Set();
  for(const [aStr, ns] of Object.entries(adj)){
    const a=Number(aStr);
    for(const b of ns){
      const key = a<b ? `${a}-${b}` : `${b}-${a}`;
      if(drawn.has(key)) continue;
      drawn.add(key);
      const p1=coord[a], p2=coord[b];
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',p1.x);
      line.setAttribute('y1',p1.y);
      line.setAttribute('x2',p2.x);
      line.setAttribute('y2',p2.y);
      svg.appendChild(line);
    }
  }
})();

// ===== 유틸 =====
function hasMill(idx, side){
  return mills.some(m => m.includes(idx) && m.every(i => board[i]===side));
}
function hasAnyMove(side){
  if(count[side]<=2) return false;
  for(let i=0;i<24;i++){
    if(board[i]!==side) continue;
    for(const n of adj[i]) if(board[n]===EMPTY) return true;
  }
  return false;
}
function updateBoardUI(){
  document.querySelectorAll('.cell').forEach(cell=>{
    const idx=Number(cell.dataset.index);
    const v=board[idx];
    cell.classList.remove('empty','W','B','selected');
    if(v===EMPTY) cell.classList.add('empty'); else cell.classList.add(v);
  });
}
function updateInfoBar(){
  const modeText=document.getElementById('mode-text');
  const turnText=document.getElementById('turn-text');
  const roleText=document.getElementById('role-text');
  const hintText=document.getElementById('hint-text');

  if(mode===MODE.SINGLE){
    const who = humanSide===WHITE ? '플레이어: 흰 말' : '플레이어: 검은 말';
    modeText.textContent=`혼자 게임하기 (${who})`;
  }else if(mode===MODE.MULTI){
    modeText.textContent='둘이 게임하기';
  }else modeText.textContent='';

  let t=currentSide===WHITE?'흰 말 차례':'검은 말 차례';
  if(mode===MODE.SINGLE){
    t += currentSide===humanSide?' (플레이어)':' (컴퓨터)';
  }
  turnText.textContent=t;

  roleText.textContent = isMovingPhase()
    ? '이동 단계: 자신의 말을 인접한 빈 점으로 한 칸 이동합니다.'
    : '포석 단계: 번갈아 자신의 말을 빈 점에 놓습니다. (각 9개)';

  if(pendingRemovalSide){
    if(mode===MODE.SINGLE && pendingRemovalSide===aiSide){
      hintText.textContent='컴퓨터가 말을 제거하는 중...';
    }else{
      hintText.textContent='밀 완성! 제거할 상대 말을 클릭하세요.';
    }
  }else{
    hintText.textContent='';
  }
}
function resetGame(){
  board=Array(24).fill(EMPTY);
  currentSide=WHITE;
  humanSide=null; aiSide=null;
  placed={W:0,B:0};
  count={W:0,B:0};
  selectedIndex=null;
  pendingRemovalSide=null;
  gameOver=false;
  updateBoardUI();
  updateInfoBar();
}
function endGame(winner){
  gameOver=true;
  const ov=document.getElementById('result-overlay');
  const msg=document.getElementById('result-message');
  const detail=document.getElementById('result-detail');
  msg.textContent = winner===WHITE?'흰 말 승리!':'검은 말 승리!';
  detail.textContent='상대 말이 2개 이하이거나 더 이상 움직일 수 없습니다.';
  ov.classList.remove('hidden');
}
function computeWinner(moverSide){
  if(!isMovingPhase()) return null; // 포석 단계에서는 승부 안 남
  const opp=otherSide(moverSide);
  if(count[opp]<=2) return moverSide;
  if(!hasAnyMove(opp)) return moverSide;
  return null;
}

// 한 턴이 끝난 뒤 공통 처리 (포석/이동 모두)
function onMoveFinished(lastIdx){
  const side=currentSide;
  const opp=otherSide(side);

  // 밀 완성 → 제거 모드 진입
  if(hasMill(lastIdx,side) && count[opp]>0){
    pendingRemovalSide = side;
    updateBoardUI();
    updateInfoBar();

    // AI가 만든 밀이면, 즉시 자동 제거
    if(mode===MODE.SINGLE && side===aiSide){
      const targets=[];
      for(let i=0;i<24;i++) if(board[i]===opp) targets.push(i);
      if(targets.length){
        const t=targets[Math.floor(Math.random()*targets.length)];
        board[t]=EMPTY;
        count[opp]--;
      }
      pendingRemovalSide=null;
      updateBoardUI();

      const w=computeWinner(side);
      if(w){ endGame(w); return; }

      currentSide=opp;
      updateInfoBar();
      if(mode===MODE.SINGLE && currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
    }
    // 사람이 만든 밀이면, 여기서 멈추고 클릭으로 제거 기다림
    return;
  }

  // 밀이 없었으면 → 승부 체크 후 턴 넘김
  const w=computeWinner(side);
  if(w){ endGame(w); return; }

  currentSide=opp;
  updateInfoBar();
  if(mode===MODE.SINGLE && currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
}

// ===== 사람 클릭 처리 =====
function handleCellClick(e){
  if(gameOver) return;
  const target=e.target.closest('.cell');
  if(!target) return;
  const idx=Number(target.dataset.index);
  if(Number.isNaN(idx)) return;

  // 제거 모드일 때: 상대 말 클릭해서 제거
  if(pendingRemovalSide){
    const remover=pendingRemovalSide;
    const victimSide=otherSide(remover);

    // 싱글에서 AI가 제거해야 하는 턴이면 사람 입력 무시
    if(mode===MODE.SINGLE && remover===aiSide) return;

    if(board[idx]!==victimSide) return; // 상대 말만 제거 가능

    board[idx]=EMPTY;
    count[victimSide]--;
    pendingRemovalSide=null;
    updateBoardUI();

    const w=computeWinner(remover);
    if(w){ endGame(w); return; }

    currentSide=victimSide; // 제거한 사람 턴 끝 → 상대에게 넘김
    updateInfoBar();
    if(mode===MODE.SINGLE && currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
    return;
  }

  // AI 차례엔 입력 막기
  if(mode===MODE.SINGLE && currentSide===aiSide) return;

  // 포석 단계
  if(!isMovingPhase()){
    if(board[idx]!==EMPTY) return;
    board[idx]=currentSide;
    placed[currentSide]++; count[currentSide]++;
    updateBoardUI();
    onMoveFinished(idx);
    return;
  }

  // 이동 단계
  if(selectedIndex===null){
    if(board[idx]!==currentSide) return;
    selectedIndex=idx;
    cellEl(idx).classList.add('selected');
    return;
  }else{
    if(idx===selectedIndex){
      cellEl(idx).classList.remove('selected');
      selectedIndex=null;
      return;
    }
    if(board[idx]!==EMPTY){
      // 같은 편 다른 말 선택으로 변경
      if(board[idx]===currentSide){
        cellEl(selectedIndex).classList.remove('selected');
        selectedIndex=idx;
        cellEl(idx).classList.add('selected');
      }
      return;
    }
    const from=selectedIndex, to=idx;
    if(!adj[from].includes(to)) return;
    board[from]=EMPTY;
    board[to]=currentSide;
    cellEl(from).classList.remove('selected');
    selectedIndex=null;
    updateBoardUI();
    onMoveFinished(to);
  }
}

// ===== AI =====
function aiTurn(){
  if(gameOver) return;
  if(currentSide!==aiSide) return;
  // 제거 모드에서는 onMoveFinished가 이미 AI 쪽 제거를 처리하므로,
  // 여기까지 오면 항상 "말 놓거나 움직이는" 턴이다.

  // 포석 단계
  if(!isMovingPhase()){
    const empties=[];
    for(let i=0;i<24;i++) if(board[i]===EMPTY) empties.push(i);
    if(!empties.length) return;

    const opp = humanSide ?? otherSide(aiSide);

    let choice=null;

    // 1) 내 밀 만드는 수
    for(const i of empties){
      board[i]=aiSide;
      const ok=hasMill(i,aiSide);
      board[i]=EMPTY;
      if(ok){ choice=i; break; }
    }

    // 2) 상대 밀 막는 수
    if(choice===null){
      for(const i of empties){
        board[i]=opp;
        const ok=hasMill(i,opp);
        board[i]=EMPTY;
        if(ok){ choice=i; break; }
      }
    }

    // 3) 그 외 랜덤
    if(choice===null) choice=empties[Math.floor(Math.random()*empties.length)];

    board[choice]=aiSide;
    placed[aiSide]++; count[aiSide]++;
    updateBoardUI();
    onMoveFinished(choice);
    return;
  }

  // 이동 단계
  const moves=[];
  for(let from=0;from<24;from++){
    if(board[from]!==aiSide) continue;
    for(const to of adj[from]) if(board[to]===EMPTY) moves.push({from,to});
  }
  if(!moves.length){
    const w=computeWinner(aiSide);
    if(w) endGame(w);
    return;
  }

  const opp = humanSide ?? otherSide(aiSide);
  let chosen=null;

  // 1) 밀 만드는 이동
  for(const m of moves){
    board[m.from]=EMPTY; board[m.to]=aiSide;
    const ok=hasMill(m.to,aiSide);
    board[m.to]=EMPTY; board[m.from]=aiSide;
    if(ok){ chosen=m; break; }
  }

  // 2) 상대 밀 막는 이동 (대략적으로: 상대가 그 칸에 두면 밀인 자리 차지)
  if(!chosen){
    for(const m of moves){
      board[m.from]=EMPTY; board[m.to]=opp;
      const ok=hasMill(m.to,opp);
      board[m.to]=EMPTY; board[m.from]=aiSide;
      if(ok){ chosen=m; break; }
    }
  }

  // 3) 랜덤 이동
  if(!chosen) chosen=moves[Math.floor(Math.random()*moves.length)];

  board[chosen.from]=EMPTY;
  board[chosen.to]=aiSide;
  updateBoardUI();
  onMoveFinished(chosen.to);
}

// ===== 이벤트 바인딩 =====
document.querySelectorAll('.cell').forEach(c=>{
  c.addEventListener('click',handleCellClick);
});

document.getElementById('btn-single').onclick=()=>{
  mode=MODE.SINGLE;
  resetGame();
  // 선/후공 랜덤
  humanSide = Math.random()<0.5 ? WHITE : BLACK;
  aiSide = otherSide(humanSide);
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');
  updateInfoBar();
  if(currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
};

document.getElementById('btn-multi').onclick=()=>{
  mode=MODE.MULTI;
  resetGame();
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');
  updateInfoBar();
};

document.getElementById('btn-back').onclick=()=>{
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};

document.getElementById('btn-restart').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};

document.getElementById('btn-to-start').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};
</script>

</body>
</html>


<!-- © 2025 이 자료의 저작권은 quasar.sch에게 있습니다. -->
